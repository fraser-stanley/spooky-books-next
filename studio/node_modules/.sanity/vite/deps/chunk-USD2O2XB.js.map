{
  "version": 3,
  "sources": ["../../../@sanity/telemetry/src/utils/browserEvents.ts", "../../../@sanity/telemetry/src/noopLogger.ts", "../../../@sanity/telemetry/src/react/useTelemetryStoreLifeCycleEvents.ts", "../../../@sanity/telemetry/src/react/TelemetryProvider.tsx", "../../../@sanity/telemetry/src/react/useTelemetry.ts"],
  "sourcesContent": ["import {TelemetryStore} from '@sanity/telemetry'\n\nconst capture = {capture: true}\n\nfunction listen(target: EventTarget, type: string, cb: () => void) {\n  target.addEventListener(type, cb, capture)\n  return () => target.removeEventListener(type, cb, capture)\n}\n\nexport function onPageHide(listener: () => void) {\n  // prefer pagehide to unload event\n  if ('onpagehide' in window) {\n    return listen(window, 'pagehide', listener)\n  }\n  // only register beforeunload/unload in browsers that don't support\n  // pagehide to avoid breaking bfcache\n  const cleanupUnload = listen(window, 'unload', listener)\n  const cleanupBeforeUnload = listen(window, 'unload', listener)\n  return () => {\n    cleanupUnload()\n    cleanupBeforeUnload()\n  }\n}\n\nexport function onVisibilityHidden(cb: () => void) {\n  return listen(document, 'visibilitychange', () => {\n    if (document.visibilityState === 'hidden') {\n      cb()\n    }\n  })\n}\n\nexport function registerLifecycleEvents(store: TelemetryStore<unknown>) {\n  const unregisterVisibilityHidden = onVisibilityHidden(() => store.flush())\n  const unregisterPageHide = onPageHide(() => store.endWithBeacon())\n  return () => {\n    unregisterPageHide()\n    unregisterVisibilityHidden()\n  }\n}\n", "import {DefinedTelemetryTrace, TelemetryLogger, TelemetryTrace} from './types'\n\nfunction createNoopLogger(): TelemetryLogger<unknown> {\n  const logger = {\n    updateUserProperties() {},\n    trace,\n    log,\n  }\n  function trace(\n    telemetryTrace: DefinedTelemetryTrace<unknown, unknown>,\n  ): TelemetryTrace<unknown, unknown> {\n    return {\n      start() {},\n      log(data?: unknown) {},\n      complete() {},\n      newContext(name: string) {\n        return logger\n      },\n      error(error: Error) {},\n      await: (promise: Promise<unknown>) => promise,\n    }\n  }\n\n  function log(event: unknown, data?: unknown) {}\n\n  return logger\n}\n\nexport const noopLogger = createNoopLogger()\n", "import type {TelemetryStore} from '../types'\nimport {useEffect} from 'react'\nimport {onPageHide, onVisibilityHidden} from '../utils/browserEvents'\n\nexport function useTelemetryStoreLifeCycleEvents(\n  store: TelemetryStore<unknown>,\n) {\n  // when visibility changes to hidden, flush events, but continue tracking\n  useEffect(() => onVisibilityHidden(store.flush), [store.flush])\n  // when browser navigates away, closes or reloads the page, use provided sendBeacon method to send events\n  useEffect(() => onPageHide(store.endWithBeacon), [store.endWithBeacon])\n}\n", "import type React from 'react'\nimport {createContext} from 'react'\nimport {TelemetryLogger, TelemetryStore} from '../types'\nimport {useTelemetryStoreLifeCycleEvents} from './useTelemetryStoreLifeCycleEvents'\nimport {noopLogger} from '../noopLogger'\n\n/**\n * @internal\n */\nexport const TelemetryLoggerContext =\n  createContext<TelemetryLogger<unknown>>(noopLogger)\n\nexport function TelemetryProvider<UserProperties>({\n  children,\n  store,\n}: {\n  children: React.ReactNode\n  store: TelemetryStore<UserProperties>\n}) {\n  // Hook the telemetry store up to page life cycle events like hide/unload\n  useTelemetryStoreLifeCycleEvents(store)\n\n  return (\n    <TelemetryLoggerContext.Provider value={store.logger}>\n      {children}\n    </TelemetryLoggerContext.Provider>\n  )\n}\n", "import {useContext} from 'react'\nimport {TelemetryLoggerContext} from './TelemetryProvider'\nimport type {TelemetryLogger} from '../'\n\nexport function useTelemetry<\n  UserProperties,\n>(): TelemetryLogger<UserProperties> {\n  return useContext(TelemetryLoggerContext) as TelemetryLogger<UserProperties>\n}\n"],
  "mappings": ";;;;;;;;;;;;;;;AAEA,IAAMA,UAAU;EAACA,SAAS;;AAE1B,SAASC,OAAOC,QAAqBC,MAAcC,IAAgB;AAC1DF,SAAAG,iBAAiBF,MAAMC,IAAIJ,OAAO;AACzC,SAAO,MAAME,OAAOI,oBAAoBH,MAAMC,IAAIJ,OAAO;AAC3D;AAEO,SAASO,WAAWC,UAAsB;AAE/C,MAAI,gBAAgBC,QAAQ;AACnB,WAAAR,OAAOQ,QAAQ,YAAYD,QAAQ;EAC5C;AAGA,QAAME,gBAAgBT,OAAOQ,QAAQ,UAAUD,QAAQ;AACvD,QAAMG,sBAAsBV,OAAOQ,QAAQ,UAAUD,QAAQ;AAC7D,SAAO,MAAM;AACGE,kBAAA;AACMC,wBAAA;EAAA;AAExB;AAEO,SAASC,mBAAmBR,IAAgB;AAC1C,SAAAH,OAAOY,UAAU,oBAAoB,MAAM;AAC5C,QAAAA,SAASC,oBAAoB,UAAU;AACtCV,SAAA;IACL;EAAA,CACD;AACH;AC5BA,SAASW,mBAA6C;AACpD,QAAMC,SAAS;IACbC,uBAAuB;IAAC;IACxBC;IACAC;EAAA;AAEF,WAASD,MACPE,gBACkC;AAC3B,WAAA;MACLC,QAAQ;MAAC;MACTF,IAAIG,MAAgB;MAAC;MACrBC,WAAW;MAAC;MACZC,WAAWC,MAAc;AAChB,eAAAT;MACT;MACAU,MAAMA,OAAc;MAAC;MACrBC,OAAQC,aAA8BA;IAAA;EAE1C;AAES,WAAAT,IAAIU,OAAgBP,MAAgB;EAAC;AAEvC,SAAAN;AACT;AAEO,IAAMc,aAAaf,iBAAiB;;;ACxBpC,SAASgB,iCACdC,OACA;AAEUC,8BAAA,MAAMC,mBAAmBF,MAAMG,KAAK,GAAG,CAACH,MAAMG,KAAK,CAAC;AAEpDF,8BAAA,MAAMG,WAAWJ,MAAMK,aAAa,GAAG,CAACL,MAAMK,aAAa,CAAC;AACxE;ACFa,IAAAC,6BACXC,4BAAwCC,UAAU;AAE7C,SAASC,kBAAkCC,MAM/C;AAAA,MAN+C;IAChDC;IACAX;EACF,IAGGU;AAEDX,mCAAiCC,KAAK;AAEtC,aAAA,wBACGM,uBAAuBM,UAAvB;IAAgCC,OAAOb,MAAMc;IAC3CH;EACH,CAAA;AAEJ;ACvBO,SAASI,eAEqB;AACnC,aAAOC,yBAAWV,sBAAsB;AAC1C;",
  "names": ["capture", "listen", "target", "type", "cb", "addEventListener", "removeEventListener", "onPageHide", "listener", "window", "cleanupUnload", "cleanupBeforeUnload", "onVisibilityHidden", "document", "visibilityState", "createNoopLogger", "logger", "updateUserProperties", "trace", "log", "telemetryTrace", "start", "data", "complete", "newContext", "name", "error", "await", "promise", "event", "noopLogger", "useTelemetryStoreLifeCycleEvents", "store", "useEffect", "onVisibilityHidden", "flush", "onPageHide", "endWithBeacon", "TelemetryLoggerContext", "createContext", "noopLogger", "TelemetryProvider", "_ref", "children", "Provider", "value", "logger", "useTelemetry", "useContext"]
}
